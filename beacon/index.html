<!doctype html><html><head><meta charset='utf-8'><title>Beacon</title></head><body><h1>Beacon</h1>
<!-- =========================
     DECODER LAB (G24 + RS(31,19) + Preamble match)
     ========================= -->
<section id="decoder" style="margin:28px 0;padding:16px;border:1px solid rgba(255,255,255,.15);border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,.03),transparent)">
  <h2 style="margin:0 0 8px 0">Decoder Lab</h2>
  <p style="margin:6px 0 14px;color:#aab2c0">Quick tools to validate and decode Beacon headers and payloads. Includes a matched-filter preamble locator, a <b>Golay&nbsp;[24,12,8]</b> header checker/corrector (up to 3 bit errors), and an <b>RS(31,19)</b> erasure decoder over GF(32). Everything runs locally in your browser.</p>

  <!-- Preamble match -->
  <details open>
    <summary style="cursor:pointer;font-weight:700">1) Matched-filter preamble (p = 31 or 47)</summary>
    <div style="margin-top:10px">
      <label>Header bits (0/1): <br>
        <textarea id="mf_bits" rows="3" style="width:100%;background:rgba(255,255,255,.04);color:#e6eaf2;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px" placeholder="e.g. 1011001..."></textarea>
      </label>
      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <label>Prime p
          <select id="mf_p" style="margin-left:6px">
            <option value="31">31</option>
            <option value="47">47</option>
          </select>
        </label>
        <button id="mf_run" type="button">Run matched filter</button>
        <span id="mf_out" style="margin-left:8px;color:#9ca3af">—</span>
      </div>
    </div>
  </details>

  <!-- Golay 24 checker/corrector -->
  <details>
    <summary style="cursor:pointer;font-weight:700">2) Golay [24,12,8] header checker / corrector (≤3 bit errors)</summary>
    <div style="margin-top:10px">
      <div style="color:#9ca3af">Enter a 24-bit word (binary or hex like 0xABCDxx). We assume the 23-bit perfect Golay part uses the cyclic generator <code>g(x)=x^11+x^10+x^6+x^5+x^4+x^2+1</code>, and the 24th bit is an even-parity extension.</div>
      <label>Codeword:
        <input id="g24_word" type="text" placeholder="e.g. 1010... or 0xABCDE0" style="width:100%;margin-top:6px;background:rgba(255,255,255,.04);color:#e6eaf2;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px">
      </label>
      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <label>Parity bit position
          <select id="g24_parpos" style="margin-left:6px">
            <option value="end">bit 23 (LSB) is parity</option>
            <option value="start">bit 0 (MSB) is parity</option>
          </select>
        </label>
        <button id="g24_check" type="button">Check / Correct</button>
        <span id="g24_out" style="margin-left:8px;color:#9ca3af">—</span>
      </div>
    </div>
  </details>

  <!-- RS(31,19) erasure decoder -->
  <details>
    <summary style="cursor:pointer;font-weight:700">3) RS(31,19) over GF(32) — erasure decoder (≤12 erasures)</summary>
    <div style="margin-top:10px">
      <div style="color:#9ca3af">Paste 31 symbols in hex (0..1F). Optional: comma-separated erasure indices (0..30, where index 0 is the first symbol). Uses GF(32) with primitive polynomial <code>x^5+x^2+1</code>. Generator has roots <code>α^1..α^12</code> (t=6).</div>
      <label>Symbols (hex, space or comma separated):
        <textarea id="rs_syms" rows="3" style="width:100%;margin-top:6px;background:rgba(255,255,255,.04);color:#e6eaf2;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px" placeholder="e.g. 0e 1a 03 ..."></textarea>
      </label>
      <label style="display:block;margin-top:6px">Erasures (indices):
        <input id="rs_eras" type="text" placeholder="e.g. 5,6,7" style="width:100%;background:rgba(255,255,255,.04);color:#e6eaf2;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px">
      </label>
      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <button id="rs_check" type="button">Syndrome</button>
        <button id="rs_decode" type="button">Decode (erasures)</button>
        <span id="rs_out" style="margin-left:8px;color:#9ca3af">—</span>
      </div>
    </div>
  </details>
</section>

<script>
// ===== Matched filter (±1 correlation) =====
function bitsFromText(s){
  s = (s||'').trim();
  if(!s) return [];
  if(/^0x/i.test(s)){
    var hex = s.replace(/^0x/i,'').replace(/[^0-9a-f]/gi,'');
    var out = [];
    for(var i=0;i<hex.length;i++){
      var v = parseInt(hex[i],16);
      for(var b=3;b>=0;b--) out.push((v>>b)&1);
    }
    return out;
  }
  return s.replace(/[^01]/g,'').split('').map(ch=>ch==='1'?1:0);
}
function corr(a,b){
  // map 0->-1, 1->+1 then compute sliding correlation max
  var A = a.map(x=>x?1:-1), B = b.map(x=>x?1:-1);
  var n=A.length, m=B.length, best=-1e9, bestk=0;
  for(var k=0;k<=n-m;k++){
    var s=0; for(var i=0;i<m;i++) s += A[k+i]*B[i];
    if(s>best){ best=s; bestk=k; }
  }
  return {peak:best, offset:bestk};
}
function barkerLike(p){
  // simple ±1 Legendre sequence mod p (p prime)
  var seq = [];
  for(var n=1;n<=p;n++){
    // Legendre symbol (n|p) → {1,-1,0}; map to bits
    var ls = 1;
    // naive: n^{(p-1)/2} mod p
    var pow = 1, a=n%p, e=(p-1)/2;
    var base=a%p;
    while(e>0){
      if(e&1) pow = (pow*base)%p;
      base = (base*base)%p;
      e>>=1;
    }
    ls = (pow===1)?1:-1;
    seq.push(ls===1?1:0);
  }
  return seq;
}
document.getElementById('mf_run').onclick = function(){
  var bits = bitsFromText(document.getElementById('mf_bits').value);
  var p = +document.getElementById('mf_p').value;
  var pre = barkerLike(p);
  if(bits.length < pre.length){ document.getElementById('mf_out').textContent = 'Need ≥ '+pre.length+' bits'; return; }
  var r = corr(bits, pre);
  document.getElementById('mf_out').textContent = 'Peak '+r.peak+' at offset '+r.offset+' (len '+pre.length+')';
};

// ===== Golay (24,12,8) checker/corrector =====
// Perfect Golay (23,12,7) is cyclic with generator g(x)=x^11+x^10+x^6+x^5+x^4+x^2+1.
// Extended Golay adds one even parity bit → [24,12,8].
// Represent 23-bit words in an integer (bits 22..0).

const G23_GEN = (1<<11)|(1<<10)|(1<<6)|(1<<5)|(1<<4)|(1<<2)|1; // 0b1100001110101 = 3189

function parseBitWord(s){
  s = (s||'').trim();
  if(!s) return null;
  if(/^0x/i.test(s)){
    let v = parseInt(s,16)>>>0;
    return v;
  }
  let bits = s.replace(/[^01]/g,''); if(bits.length===0) return null;
  let v = 0; for(let i=0;i<bits.length;i++){ v = (v<<1)| (bits[i]==='1'?1:0); }
  return v>>>0;
}
function popcnt(x){ x>>>=0; let c=0; while(x){ x&=x-1; c++; } return c; }
function parity32(x){ return popcnt(x)&1; }

function modDivGF2(dividend, gen){
  // returns remainder of dividend / gen in GF(2) polynomials
  // degrees: dividend up to e.g. 33 bits, gen degree 11
  let degG = 31 - Math.clz32(gen);
  let r = dividend>>>0;
  for(let i=(31-Math.clz32(r)); i>=degG; i--){
    if(((r>>>i)&1)===1){
      r ^= (gen << (i-degG))>>>0;
    }
  }
  return r>>>0;
}
function g23_encode12(msg12){
  msg12 &= 0xFFF;
  let shifted = (msg12<<11)>>>0;
  let rem = modDivGF2(shifted, G23_GEN) & ((1<<11)-1);
  return (shifted ^ rem) & ((1<<23)-1);
}
function g23_is_codeword(c23){
  // valid if remainder is 0
  let rem = modDivGF2(c23, G23_GEN) & ((1<<11)-1);
  return rem===0;
}
function g24_check_correct(raw24, parityAtEnd=true){
  // split into c23 + parity
  let parity = parityAtEnd ? (raw24 & 1) : (raw24>>>23)&1;
  let c23 = parityAtEnd ? (raw24>>>1) : (raw24 & ((1<<23)-1));

  // search up to 3 flips in the 23-bit part
  let best = null;
  // w=0
  if(g23_is_codeword(c23)){
    let needParity = parity32(c23) & 1; // even parity across 24 → parity == (popcnt(c23) mod 2)
    let totErr = (parity!==needParity)?1:0;
    if(totErr<=3) best = {c23, parity:needParity, flips:0 if totErr==0 else 1, corrected:true};
  }
  // w=1
  if(!best){
    for(let i=0;i<23;i++){
      let c = c23 ^ (1<<i);
      if(g23_is_codeword(c)){
        let needParity = parity32(c)&1;
        let totErr = 1 + ((parity!==needParity)?1:0);
        if(totErr<=3){ best = {c23:c, parity:needParity, flips:totErr, corrected:true}; break; }
      }
    }
  }
  // w=2
  if(!best){
    for(let i=0;i<23;i++){
      for(let j=i+1;j<23;j++){
        let c = c23 ^ (1<<i) ^ (1<<j);
        if(g23_is_codeword(c)){
          let needParity = parity32(c)&1;
          let totErr = 2 + ((parity!==needParity)?1:0);
          if(totErr<=3){ best = {c23:c, parity:needParity, flips:totErr, corrected:true}; break; }
        }
      }
      if(best) break;
    }
  }
  // w=3
  if(!best){
    for(let i=0;i<23;i++){
      for(let j=i+1;j<23;j++){
        for(let k=j+1;k<23;k++){
          let c = c23 ^ (1<<i) ^ (1<<j) ^ (1<<k);
          if(g23_is_codeword(c)){
            let needParity = parity32(c)&1;
            let totErr = 3 + ((parity!==needParity)?1:0);
            if(totErr<=3){ best = {c23:c, parity:needParity, flips:totErr, corrected:true}; break; }
          }
        }
        if(best) break;
      }
      if(best) break;
    }
  }
  if(best){
    // combine back
    let cw24 = parityAtEnd ? ((best.c23<<1)|best.parity) : ((best.parity<<23)|(best.c23&((1<<23)-1)));
    return {ok:true, corrected:true, flips:best.flips, code24:cw24>>>0, msg12: (best.c23>>>11)&0xFFF };
  }
  return {ok:false, corrected:false, error:"Could not correct with ≤3 flips"};
}

document.getElementById('g24_check').onclick = function(){
  const s = document.getElementById('g24_word').value;
  const pos = document.getElementById('g24_parpos').value;
  const v = parseBitWord(s);
  if(v==null){ document.getElementById('g24_out').textContent = 'Please enter 24-bit binary or hex.'; return; }
  const parityAtEnd = (pos==='end');
  // If input wider than 24 bits, mask
  const raw24 = v & 0xFFFFFF;
  const res = g24_check_correct(raw24, parityAtEnd);
  if(res.ok){
    const hex = '0x'+(res.code24>>>0).toString(16).padStart(6,'0');
    document.getElementById('g24_out').textContent = 'OK: corrected='+res.corrected+' · flips='+res.flips+' · msg12=0x'+((res.msg12>>>0).toString(16))+' · code24='+hex;
  }else{
    document.getElementById('g24_out').textContent = 'Fail: '+res.error;
  }
};

// small helper
Number.prototype.zfill=function(n){ let s=this.toString(16); while(s.length<n)s='0'+s; return s; }

// ===== RS(31,19) over GF(32) — erasure decoder =====
const PRIM = 0x25; // x^5 + x^2 + 1
let gf_exp = new Array(62);
let gf_log = new Array(32);
(function gfInit(){
  let x = 1;
  for(let i=0;i<31;i++){
    gf_exp[i] = x;
    gf_log[x] = i;
    x <<= 1;
    if(x & 0x20){ x ^= PRIM; }
  }
  for(let i=31;i<62;i++) gf_exp[i] = gf_exp[i-31];
})();
function gadd(a,b){ return a^b; }
function gmul(a,b){ if(a===0||b===0) return 0; return gf_exp[(gf_log[a]+gf_log[b])%31]; }
function gpow(a,e){ if(a===0) return 0; return gf_exp[(gf_log[a]*e)%31]; }
function ginv(a){ if(a===0) throw new Error('inv(0)'); return gf_exp[(31-gf_log[a])%31]; }

function parseSyms(s){
  let arr = s.replace(/[^0-9a-f, 	
]/gi,' ').trim().split(/[\s,]+/).filter(Boolean).map(x=>int(x));
  function int(x){ return parseInt(x,16)&31; }
  return arr;
}
function parseEras(s){
  if(!s.trim()) return [];
  return s.split(/[\s,]+/).filter(Boolean).map(x=>+x).filter(i=>i>=0 && i<31);
}
function syndromes31(r){
  // S_j = sum r_i * α^{j*i} for j=1..12
  let S = new Array(12).fill(0);
  for(let j=1;j<=12;j++){
    let s = 0;
    for(let i=0;i<31;i++){
      let term = r[i] ? gmul(r[i], gf_exp[(j*i)%31]) : 0;
      s = gadd(s, term);
    }
    S[j-1] = s;
  }
  return S;
}
function allZero(arr){ for(let i=0;i<arr.length;i++) if(arr[i]) return false; return true; }


function solveErasures(r, eras){
  // Build m×m Vandermonde: A[j-1,c] = α^{j*e_c}, using first m equations j=1..m
  const m = eras.length;
  if(m===0) return {ok:false, msg:'No erasures provided'};
  if(m>12) return {ok:false, msg:'Too many erasures (max 12)'};
  // Right-hand side b_j = sum_{i not in E} r_i α^{j*i}
  const b = new Array(m).fill(0);
  const A = new Array(m); for(let j=0;j<m;j++){ A[j]=new Array(m).fill(0); }
  for(let j=1;j<=m;j++){
    let s = 0;
    for(let i=0;i<31;i++){
      if(eras.indexOf(i)>=0) continue;
      if(r[i]) s = gadd(s, gmul(r[i], gf_exp[(j*i)%31]));
    }
    b[j-1] = s;
    for(let c=0;c<m;c++){
      A[j-1][c] = gf_exp[(j*eras[c])%31];
    }
  }
  // Solve A x = (-b); over GF(2^m), -b == b
  // Augment
  for(let i=0;i<m;i++){ A[i].push(b[i]); }
  // Gauss-Jordan
  let row = 0;
  for(let col=0; col<m && row<m; col++){
    // pivot
    let piv = -1;
    for(let r2=row;r2<m;r2++){ if(A[r2][col]){ piv=r2; break; } }
    if(piv===-1) continue; // skip zero column (should not happen for distinct erasures)
    if(piv!==row){ let tmp=A[row]; A[row]=A[piv]; A[piv]=tmp; }
    // scale to 1
    let inv = ginv(A[row][col]);
    for(let c=col;c<=m;c++){ A[row][c] = gmul(A[row][c], inv); }
    // eliminate
    for(let r2=0;r2<m;r2++){
      if(r2===row) continue;
      let f = A[r2][col];
      if(f){
        for(let c=col;c<=m;c++){ A[r2][c] = gadd(A[r2][c], gmul(f, A[row][c])); }
      }
    }
    row++;
  }
  if(row<m) return {ok:false, msg:'Singular matrix (duplicate erasure indices?)'};
  const x = new Array(m);
  for(let i=0;i<m;i++){ x[i] = A[i][m] & 31; }
  const out = r.slice();
  for(let i=0;i<m;i++){ out[eras[i]] = x[i]; }
  const S = syndromes31(out);
  if(!allZero(S)) return {ok:false, msg:'Decode failed: residual syndromes '+S.map(v=>v.toString(16).padStart(2,'0')).join(' ')};
  return {ok:true, code:out};
}
}

document.getElementById('rs_check').onclick = function(){
  const r = parseSyms(document.getElementById('rs_syms').value);
  if(r.length!==31){ document.getElementById('rs_out').textContent='Need exactly 31 symbols (hex 00..1F).'; return; }
  const S = syndromes31(r);
  const zero = allZero(S);
  document.getElementById('rs_out').textContent = zero ? 'Syndromes all zero — codeword is valid' : ('S: '+S.map(v=>v.toString(16).padStart(2,'0')).join(' '));
};
document.getElementById('rs_decode').onclick = function(){
  const r = parseSyms(document.getElementById('rs_syms').value);
  const eras = parseEras(document.getElementById('rs_eras').value);
  if(r.length!==31){ document.getElementById('rs_out').textContent='Need exactly 31 symbols.'; return; }
  const res = solveErasures(r, eras);
  if(!res.ok){ document.getElementById('rs_out').textContent = 'Fail: '+res.msg; return; }
  document.getElementById('rs_out').textContent = 'Decoded: '+res.code.map(v=>v.toString(16).padStart(2,'0')).join(' ')+' (first 19 symbols are payload)';
};
</script>

</body></html>
